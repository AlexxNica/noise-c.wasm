// Generated by LiveScript 1.5.0
/**
 * @package   noise-c.wasm
 * @author    Nazar Mokrynskyi <nazar@mokrynskyi.com>
 * @copyright Copyright (c) 2017, Nazar Mokrynskyi
 * @license   MIT License, see license.txt
 */
(function(){
  var randombytes, lib, test;
  randombytes = require('crypto').randomBytes;
  lib = require('..');
  test = require('tape');
  lib.ready(function(){
    var i$, ref$, len$, cipher, j$, ref1$, len1$, plaintext, k$, ref2$, len2$, ad;
    for (i$ = 0, len$ = (ref$ = ['NOISE_CIPHER_CHACHAPOLY', 'NOISE_CIPHER_AESGCM']).length; i$ < len$; ++i$) {
      cipher = ref$[i$];
      for (j$ = 0, len1$ = (ref1$ = [new Uint8Array, new Uint8Array(randombytes(10))]).length; j$ < len1$; ++j$) {
        plaintext = ref1$[j$];
        for (k$ = 0, len2$ = (ref2$ = [new Uint8Array, randombytes(256)]).length; k$ < len2$; ++k$) {
          ad = ref2$[k$];
          test("CipherState (" + cipher + ", plaintext length " + plaintext.length + ", ad length " + ad.length + "): Encryption/decryption with additional data", fn$);
        }
      }
    }
    function fn$(t){
      var key, cs1, ciphertext, ciphertext2, cs2, plaintext_decrypted, cs3, cs4;
      key = randombytes(32);
      t.doesNotThrow(function(){
        cs1 = new lib.CipherState(lib.constants[cipher]);
      }, "Constructor doesn't throw an error");
      t.equal(cs1.HasKey(), false, 'No key initially');
      cs1.InitializeKey(key);
      t.equal(cs1.HasKey(), true, 'Key was initialized');
      t.doesNotThrow(function(){
        ciphertext = cs1.EncryptWithAd(ad, plaintext);
      }, "EncryptWithAd() doesn't throw an error");
      t.equal(ciphertext.length, plaintext.length + cs1._mac_length, 'ciphertext length is plaintext length + MAC');
      t.notEqual(plaintext.toString(), ciphertext.slice(0, plaintext.length).toString(), 'Plaintext and ciphertext are different');
      ciphertext2 = cs1.EncryptWithAd(ad, plaintext);
      t.notEqual(ciphertext.toString(), ciphertext2.toString(), "Subsequent encryption doesn't have the same result");
      cs1.free();
      t.throws(function(){
        cs1.EncryptWithAd(new Uint8Array, plaintext);
      }, "CipherState shouldn't be usable after free() is called");
      cs2 = new lib.CipherState(lib.constants[cipher]);
      cs2.InitializeKey(key);
      t.doesNotThrow(function(){
        plaintext_decrypted = cs2.DecryptWithAd(ad, ciphertext);
      }, "DecryptWithAd() doesn't throw an error");
      t.equal(plaintext.toString(), plaintext_decrypted.toString(), 'Plaintext decrypted correctly');
      t.throws(function(){
        cs2.DecryptWithAd(ad, ciphertext);
      }, Error, 'Subsequent decryption fails');
      cs2.free();
      cs3 = new lib.CipherState(lib.constants[cipher]);
      cs3.InitializeKey(key);
      t.throws(function(){
        cs3.DecryptWithAd(randombytes(256), ciphertext);
      }, Error, 'Plaintext decryption with incorrect additional data fails');
      cs3.free();
      cs4 = new lib.CipherState(lib.constants[cipher]);
      cs4.InitializeKey(key);
      t.throws(function(){
        cs4.DecryptWithAd(ad, randombytes(256));
      }, Error, 'Plaintext decryption with incorrect ciphertext fails');
      cs4.free();
      t.end();
    }
  });
}).call(this);
