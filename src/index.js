// Generated by LiveScript 1.5.0
/**
 * @package   noise-c.wasm
 * @author    Nazar Mokrynskyi <nazar@mokrynskyi.com>
 * @copyright Copyright (c) 2017, Nazar Mokrynskyi
 * @license   MIT License, see license.txt
 */
(function(){
  var constants, lib, allocate;
  constants = require('./constants');
  lib = require('../noise-c')();
  allocate = lib.allocateBytes;
  module.exports = {
    ready: lib.then,
    constants: constants,
    CipherState: CipherState
  };
  /**
   * @param {string} cipher constants.NOISE_CIPHER_CHACHAPOLY, constants.NOISE_CIPHER_AESGCM, etc.
   */
  function CipherState(cipher){
    var tmp;
    tmp = lib.allocatePointer();
    if (lib._noise_cipherstate_new_by_id(tmp, cipher) !== constants.NOISE_ERROR_NONE) {
      throw 'Error';
    }
    this._state = tmp.dereference();
    this._mac_length = lib._noise_cipherstate_get_mac_length(this._state);
    tmp.free();
  }
  CipherState.prototype = {
    /**
     * @param {Uint8Array} key
     */
    InitializeKey: function(key){
      key = allocate(0, key);
      if (lib._noise_cipherstate_init_key(this._state, key, key.length) !== constants.NOISE_ERROR_NONE) {
        throw 'Error';
      }
      key.free();
    },
    HasKey: function(){
      return lib._noise_cipherstate_has_key(this._state) === 1;
    }
    /**
     * @param {Uint8Array} ad
     * @param {Uint8Array} plaintext
     *
     * @return {Uint8Array}
     */,
    EncryptWithAd: function(ad, plaintext){
      var buffer, result, ciphertext;
      buffer = allocate(lib._NoiseBuffer_struct_size());
      plaintext = allocate(plaintext.length + this._mac_length, plaintext);
      lib._NoiseBuffer_set_buffer_data(buffer, plaintext, plaintext.length - this._mac_length, plaintext.length);
      result = lib._noise_cipherstate_encrypt_with_ad(this._state, ad, ad.length, buffer);
      ciphertext = plaintext.get();
      buffer.free();
      plaintext.free();
      if (result !== constants.NOISE_ERROR_NONE) {
        throw 'Error';
      }
      return ciphertext;
    }
    /**
     * @param {Uint8Array} ad
     * @param {Uint8Array} ciphertext
     *
     * @return {Uint8Array}
     */,
    DecryptWithAd: function(ad, ciphertext){
      var buffer, result, plaintext;
      buffer = allocate(lib._NoiseBuffer_struct_size());
      ciphertext = allocate(0, ciphertext);
      lib._NoiseBuffer_set_buffer_data(buffer, ciphertext, ciphertext.length, ciphertext.length);
      result = lib._noise_cipherstate_decrypt_with_ad(this._state, ad, ad.length, buffer);
      plaintext = ciphertext.get().slice(0, ciphertext.length - this._mac_length);
      buffer.free();
      ciphertext.free();
      if (result !== constants.NOISE_ERROR_NONE) {
        throw 'Error';
      }
      return plaintext;
    },
    Rekey: function(){
      throw 'Not implemented';
    },
    free: function(){
      lib._noise_cipherstate_free(this._state);
      delete this._state;
      delete this._mac_length;
    }
  };
}).call(this);
